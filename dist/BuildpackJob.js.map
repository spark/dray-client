{"version":3,"sources":["../src/BuildpackJob.js"],"names":["promisifyAll","RedisClient","prototype","BuildpackJob","manager","parameters","redisExpireIn","_redisExpireIn","_files","_buildpacks","_manager","setEnvironment","REDIS_URL","_redisUrl","REDIS_EXPIRE_IN","files","push","buildpacks","timeout","buildpack","env","INPUT_FROM_STDIN","ARCHIVE_OUTPUT","addStep","undefined","args","source","name","refresh","networkMode","cpuShares","memory","apply","Promise","_prepareInput","bind","then","_onResolved","_onRejected","callback","length","_archiveFiles","archive","setInput","client","createClient","hgetallAsync","id","output","quit","getLogs","logs","reject","_resolve","_reject","promise","resolve","stream","buffer","Buffer","on","data","concat","gzip","err","pipe","file","append","finalize"],"mappings":";;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AAGA;;AACA;;;;;;;;;;;;AAHA,mBAASA,YAAT,CAAsB,gBAAMC,WAAN,CAAkBC,SAAxC;;IAKaC,Y,WAAAA,Y;;;AACZ;;;;;;;AAOA,uBAAYC,OAAZ,EAAqBC,UAArB,EAAoD;AAAA,MAAnBC,aAAmB,uEAAL,GAAK;;AAAA;;AAAA,0HAC7CF,OAD6C,EACpCC,UADoC;;AAGnD,QAAKE,cAAL,GAAsBD,aAAtB;AACA,QAAKE,MAAL,GAAc,EAAd;AACA,QAAKC,WAAL,GAAmB,EAAnB;;AAEA,MAAI,MAAKC,QAAT,EAAmB;AAClB,SAAKC,cAAL,CAAoB;AACnBC,eAAW,MAAKF,QAAL,CAAcG,SADN;AAEnBC,qBAAiB,MAAKP;AAFH,IAApB;AAIA;AAZkD;AAanD;;AAED;;;;;;;;;;;;;;;;;2BAaSQ,K,EAAO;AAAA;;AACf,kBAAKP,MAAL,EAAYQ,IAAZ,kCAAoBD,KAApB;AACA,UAAO,IAAP;AACA;;AAED;;;;;;;;;;gCAOcE,U,EAAY;AACzB,QAAKR,WAAL,GAAmBQ,UAAnB;AACA,QAAKR,WAAL,CAAiBO,IAAjB,CAAsB,0BAAtB;AACA,UAAO,IAAP;AACA;;AAED;;;;;;;;;yBAMOE,O,EAAS;AAAA;AAAA;AAAA;;AAAA;AACf,yBAAsB,KAAKT,WAA3B,8HAAwC;AAAA,SAA/BU,SAA+B;;AACvC;AACA;AACA,SAAIC,MAAM;AACTC,wBAAkB,IADT;AAETC,sBAAgB;AAFP,MAAV;;AAKA,SAAI,OAAOH,SAAP,KAAqB,QAAzB,EAAmC;AAClC,WAAKI,OAAL,CAAaJ,SAAb,EAAwBC,GAAxB,EAA6BI,SAA7B,EAAwC,gBAAxC;AACA,MAFD,MAEO;AACN,UAAIC,OAAO,CACVN,UAAUO,MADA,EAEVN,GAFU,EAGVD,UAAUQ,IAHA,EAIV,gBAJU,EAKVR,UAAUS,OAAV,GAAoBT,UAAUS,OAA9B,GAAwCJ,SAL9B,EAMVL,UAAUU,WAAV,GAAwBV,UAAUU,WAAlC,GAAgDL,SANtC,EAOVL,UAAUW,SAAV,GAAsBX,UAAUW,SAAhC,GAA4CN,SAPlC,EAQVL,UAAUY,MAAV,GAAmBZ,UAAUY,MAA7B,GAAsCP,SAR5B,CAAX;AAUA,WAAKD,OAAL,CAAaS,KAAb,CAAmB,IAAnB,EAAyBP,IAAzB;AACA;AACD;AAxBc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0Bf,UAAO,IAAIQ,OAAJ,CAAY,KAAKC,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAAZ,EACLC,IADK,CACA,wGAAaD,IAAb,CAAkB,IAAlB,EAAwBjB,OAAxB,CADA,EAELkB,IAFK,CAEA,KAAKC,WAAL,CAAiBF,IAAjB,CAAsB,IAAtB,CAFA,EAGH,KAAKG,WAAL,CAAiBH,IAAjB,CAAsB,IAAtB,CAHG,CAAP;AAIA;;AAED;;;;;;;;;gCAMcI,Q,EAAU;AAAA;;AACvB;AACA,OAAI,KAAK/B,MAAL,CAAYgC,MAAZ,GAAqB,CAAzB,EAA4B;AAC3B,WAAOD,SAAS,KAAKE,aAAL,GAAqBL,IAArB,CAA0B,UAACM,OAAD,EAAa;AACtD,YAAKC,QAAL,CAAcD,OAAd;AACA,KAFe,CAAT,CAAP;AAGA;AACDH;AACA;;AAED;;;;;;;;;gCAMc;AACb;AACA,OAAIK,SAAS,gBAAMC,YAAN,CAAmB,KAAKnC,QAAL,CAAcG,SAAjC,EAA4C;AACxD,sBAAkB;AADsC,IAA5C,CAAb;AAGA,UAAO+B,OAAOE,YAAP,CAAoB,KAAKC,EAAzB,EAA6BX,IAA7B,CAAkC,UAACY,MAAD,EAAY;AACpDJ,WAAOK,IAAP;AACA;AACA,WAAOD,MAAP;AACA,IAJM,CAAP;AAKA;;AAED;;;;;;;;gCAKc;AACb,UAAO,KAAKE,OAAL,GAAed,IAAf,CAAoB,UAACe,IAAD,EAAU;AACpC;AACA;AACA,WAAOlB,QAAQmB,MAAR,CAAeD,IAAf,CAAP;AACA,IAJM,CAAP;AAKA;;AAED;;;;;;;;;kCAMgB;AACf;AACA,OAAIE,iBAAJ;AAAA,OAAcC,gBAAd;AACA,OAAIC,UAAU,IAAItB,OAAJ,CAAY,UAACuB,OAAD,EAAUJ,MAAV,EAAqB;AAC9CC,eAAWG,OAAX;AACAF,cAAUF,MAAV;AACA,IAHa,CAAd;AAIA;AACA,OAAIK,SAAS,yBAAb;AACA,OAAIC,SAAS,IAAIC,MAAJ,CAAW,EAAX,CAAb;AACAF,UAAOG,EAAP,CAAU,QAAV,EAAoB,YAAM;AACzBP,aAASK,MAAT;AACA,IAFD;AAGAD,UAAOG,EAAP,CAAU,MAAV,EAAkB,UAACC,IAAD,EAAU;AAC3BH,aAASC,OAAOG,MAAP,CAAc,CAACJ,MAAD,EAASG,IAAT,CAAd,CAAT;AACA,IAFD;;AAIA;AACA,OAAInB,UAAU,wBAAS,KAAT,EAAgB,EAAEqB,MAAM,IAAR,EAAhB,CAAd;AACArB,WAAQkB,EAAR,CAAW,OAAX,EAAoB,UAACI,GAAD,EAAS;AAC5BV,YAAQU,GAAR;AACA,IAFD;AAGAtB,WAAQuB,IAAR,CAAaR,MAAb;;AAEA;AAxBe;AAAA;AAAA;;AAAA;AAyBf,0BAAiB,KAAKjD,MAAtB,mIAA8B;AAAA,SAArB0D,IAAqB;;AAC7BxB,aAAQyB,MAAR,CAAeD,KAAKL,IAApB,EAA0BK,IAA1B;AACA;AA3Bc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4BfxB,WAAQ0B,QAAR;AACA,UAAOb,OAAP;AACA","file":"BuildpackJob.js","sourcesContent":["import archiver from 'archiver';\nimport redis from 'redis';\nimport bluebird from 'bluebird';\nbluebird.promisifyAll(redis.RedisClient.prototype);\n\nimport { PassThrough } from 'stream';\nimport { DrayJob } from './DrayJob';\n\nexport class BuildpackJob extends DrayJob {\n\t/**\n\t * BuildpackJob class constructor.\n\t *\n\t * @param {DrayManager} manager {DrayManager} instance\n\t * @param {Object} parameters Parameters to set\n\t * @param {Number} redisExpireIn Expiration time in seconds for output stored in Redis\n\t */\n\tconstructor(manager, parameters, redisExpireIn=600) {\n\t\tsuper(manager, parameters);\n\n\t\tthis._redisExpireIn = redisExpireIn;\n\t\tthis._files = [];\n\t\tthis._buildpacks = [];\n\n\t\tif (this._manager) {\n\t\t\tthis.setEnvironment({\n\t\t\t\tREDIS_URL: this._manager._redisUrl,\n\t\t\t\tREDIS_EXPIRE_IN: this._redisExpireIn\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Add files to the job.\n\t * Array should contain {Object}s with `filename` {String} and\n\t * `data` {Buffer} or {String} properties. I.e.:\n\t *\n\t * job.addFiles([{\n\t * \tfilename: 'foo.ino',\n\t * \tdata: fs.readFileSync('foo.ino')\n\t * }]);\n\t *\n\t * @param {Array} files Array of files to add\n\t * @returns {this} `this` object\n\t */\n\taddFiles(files) {\n\t\tthis._files.push(...files);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets buildpacks to be used during compilation.\n\t * List will be appended by storing buildpack.\n\t *\n\t * @param {Array} buildpacks {Array} of {String}s specifying Docker images\n\t * @returns {this} `this` object\n\t */\n\tsetBuildpacks(buildpacks) {\n\t\tthis._buildpacks = buildpacks;\n\t\tthis._buildpacks.push('particle/buildpack-store');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Submits job\n\t *\n\t * @param  {Number} timeout Job timeout in ms\n\t * @return {Promise} Will resolve when job finished.\n\t */\n\tsubmit(timeout) {\n\t\tfor (let buildpack of this._buildpacks) {\n\t\t\t// We want each buildpack to pass output directory to input of a\n\t\t\t// next one. Setting following envs and output argument does that\n\t\t\tlet env = {\n\t\t\t\tINPUT_FROM_STDIN: true,\n\t\t\t\tARCHIVE_OUTPUT: true\n\t\t\t};\n\n\t\t\tif (typeof buildpack === 'string') {\n\t\t\t\tthis.addStep(buildpack, env, undefined, '/output.tar.gz');\n\t\t\t} else {\n\t\t\t\tlet args = [\n\t\t\t\t\tbuildpack.source,\n\t\t\t\t\tenv,\n\t\t\t\t\tbuildpack.name,\n\t\t\t\t\t'/output.tar.gz',\n\t\t\t\t\tbuildpack.refresh ? buildpack.refresh : undefined,\n\t\t\t\t\tbuildpack.networkMode ? buildpack.networkMode : undefined,\n\t\t\t\t\tbuildpack.cpuShares ? buildpack.cpuShares : undefined,\n\t\t\t\t\tbuildpack.memory ? buildpack.memory : undefined\n\t\t\t\t];\n\t\t\t\tthis.addStep.apply(this, args);\n\t\t\t}\n\t\t}\n\n\t\treturn new Promise(this._prepareInput.bind(this))\n\t\t\t.then(super.submit.bind(this, timeout))\n\t\t\t.then(this._onResolved.bind(this),\n\t\t\t\t\t\tthis._onRejected.bind(this));\n\t}\n\n\t/**\n\t * If any files were passed, archive them and set as input.\n\t *\n\t * @param {Function} callback Callback when finished\n\t * @returns {Mixed} {undefined} or result of the callback\n\t */\n\t_prepareInput(callback) {\n\t\t// If we have files to compile, archive them first\n\t\tif (this._files.length > 0) {\n\t\t\treturn callback(this._archiveFiles().then((archive) => {\n\t\t\t\tthis.setInput(archive);\n\t\t\t}));\n\t\t}\n\t\tcallback();\n\t}\n\n\t/**\n\t * Callback for successful compilation. Any contents of last buildpack's\n\t * output should be in Redis. This will fetch and return it.\n\t *\n\t * @returns {Promise} Resolved with job output\n\t */\n\t_onResolved() {\n\t\t// Compilation finished.\n\t\tlet client = redis.createClient(this._manager._redisUrl, {\n\t\t\t'return_buffers': true\n\t\t});\n\t\treturn client.hgetallAsync(this.id).then((output) => {\n\t\t\tclient.quit();\n\t\t\t// Return the output\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Callback for failed compilation.\n\t *\n\t * @return {Promise} Rejected promise with logs\n\t */\n\t_onRejected() {\n\t\treturn this.getLogs().then((logs) => {\n\t\t\t// Because successful `getLogs` call resolves instead of rejecting\n\t\t\t// we're returning a rejected promise instead\n\t\t\treturn Promise.reject(logs);\n\t\t});\n\t}\n\n\t/**\n\t * Create tar.gz archive from files\n\t *\n\t * @returns {Buffer} archived files\n\t * @private\n\t */\n\t_archiveFiles() {\n\t\t// Defer promise\n\t\tlet _resolve, _reject;\n\t\tlet promise = new Promise((resolve, reject) => {\n\t\t\t_resolve = resolve;\n\t\t\t_reject = reject;\n\t\t});\n\t\t// Prepare output stream and buffer\n\t\tlet stream = new PassThrough();\n\t\tlet buffer = new Buffer('');\n\t\tstream.on('finish', () => {\n\t\t\t_resolve(buffer);\n\t\t});\n\t\tstream.on('data', (data) => {\n\t\t\tbuffer = Buffer.concat([buffer, data]);\n\t\t});\n\n\t\t// Initialize archiver\n\t\tlet archive = archiver('tar', { gzip: true });\n\t\tarchive.on('error', (err) => {\n\t\t\t_reject(err);\n\t\t});\n\t\tarchive.pipe(stream);\n\n\t\t// Append all files\n\t\tfor (let file of this._files) {\n\t\t\tarchive.append(file.data, file);\n\t\t}\n\t\tarchive.finalize();\n\t\treturn promise;\n\t}\n}\n"]}